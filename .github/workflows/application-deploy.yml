name: Deploy Application And Argo CD

on:
    workflow_run:
      workflows: ["Infrastructure Deployment"]
      types:
        - completed
    push:
      paths:
        - "argocd/**"
        - ".github/workflows/application-deploy.yml"
      branches:
        - dev
        - staging
        - main
        - eks

env:
  AWS_REGION: us-east-1
  ROLE_TO_ASSUME: arn:aws:iam::${{ secrets.YOUR_AWS_ACCOUNT_ID }}:role/${{ vars.YOUR_AWS_GITHUB_ROLE }}
  ROLE_SESSION_NAME: GitHub_to_AWS_via_FederatedOIDC
  ENVIRONMENT: ${{ github.ref_name == 'main' && 'prod' || github.ref_name }}
  PROJECT_NAME: ${{ vars.PROJECT_NAME }}

permissions:
  id-token: write
  contents: read

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    defaults:
     run:
      working-directory: ./applications

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set Up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Cache Maven Dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Build with Maven
        run: mvn clean package -DskipTests

      - name: Run Unit Tests
        run: mvn test
  dockerize-and-push-to-registry:
    runs-on: ubuntu-latest
    needs: build-and-test
    defaults:
     run:
      working-directory: ./applications

    steps:
      - name: Set short git commit SHA
        id: commit
        uses: prompt/actions-commit-hash@v2

      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_TO_ASSUME }}
          role-session-name: ${{ env.ROLE_SESSION_NAME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ github.ref_name }}-${{ env.PROJECT_NAME }}-repo
          IMAGE_TAG: ${{ steps.commit.outputs.short }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f Dockerfile .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "::set-output name=image::$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
    
  deploy-argocd:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set Up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_TO_ASSUME }}
          role-session-name: ${{ env.ROLE_SESSION_NAME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Authenticate with EKS Cluster
        run: |
          aws eks update-kubeconfig --name ${{env.ENVIRONMENT}}-${{ vars.PROJECT_NAME }}-cluster --region ${{ env.AWS_REGION }}

      - name: Install Argo CD
        run: |
          if kubectl get namespace argocd >/dev/null 2>&1; then
            echo "Argo CD namespace already exists. Skipping installations."
          else
            echo "Installing Argo CD..."
            kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
            kubectl wait --namespace argocd --for=condition=ready pod --selector=app.kubernetes.io/name=argocd-server --timeout=300s
          fi
      - name: Get Argo CD DNS and Admin Password
        run: |
            # Retrieve the DNS (Load Balancer address)
            if kubectl get svc argocd-server -n argocd >/dev/null 2>&1; then
              ARGOCD_SERVER_DNS=$(kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
              echo "Argo CD Server DNS: $ARGOCD_SERVER_DNS"
            else
              echo "Argo CD service not found. DNS not available."
            fi
  
            # Retrieve the Argo CD admin password
            if kubectl get secret argocd-initial-admin-secret -n argocd >/dev/null 2>&1; then
              ARGOCD_ADMIN_PASSWORD=$(kubectl get secret argocd-initial-admin-secret -n argocd -o jsonpath='{.data.password}' | base64 --decode)
              echo "Argo CD Admin Password: $ARGOCD_ADMIN_PASSWORD"
            else
              echo "Argo CD admin secret not found. Password not available."
            fi
      # - name: Configure Argo CD Repositories
      #   run: |
      #     kubectl apply -f ./argocd/repositories.yaml

      # - name: Apply Argo CD Applications
      #   run: |
      #     kubectl apply -f ./argocd/applications.yaml